/**
 * Given a query and some collections build up a connection registery that
 * contains all the needed active connections to perform the query.
 */


var Connection = module.exports = function Connection (criteria, collections) {

  // Build an object to hold the connection registry
  this.registry = {};




};


/**
 * [buildConnection description]
 * @return {[type]} [description]
 */

Connection.prototype.buildConnection = function buildConnection (join, collections) {

  var connection;

  // Default structure for connection objects
  var defaultConnection = {
    collections: [],
    children: [],
    joins: []
  };

  // Grab the parent collection used in the join
  var collection = collections[join.parent];

  // Find the connection object in the registry
  var connectionName = collection.adapterDictionary['find'];

  // If this join is a junctionTable, find the parent operation and add it to
  // that connection's children instead of creating a new operation on another
  // connection. This allows cross-connection many-to-many joins to be used
  // where the join relies on the results of the parent operation being run
  // first.

  if(join.junctionTable) {

    // Find the connection object in the registry
    var parentConnection = this.getConnection(connectionName);

    // Find the connection the child collection belongs to
    var childCollection = collections[join.child];
    var childConnectionName = childCollection.adapterDictionary['find'];
    var childConnection = this.getConnection(childConnectionName);

    // We need to look and see if the child in the junction table is on the
    // parent connection or the child connection.




    // Update the registry with the join values
    connections[childConnectionName].collections.push(join.child);
    connections[connectionName].children.push(join.parent);

    // Add the join to the joins array for this connection
    connections[connectionName].joins = connections[connectionName].joins.concat(join);

    return;
  }

  function updateRegistry(collName) {
    var collection = self.context.waterline.collections[collName];
    var connectionName = collection.adapterDictionary['find'];
    connections[connectionName] = connections[connectionName] || _.cloneDeep(defaultConnection);

    // Update the registry with the join values
    connections[connectionName].collections.push(collection.identity);
  }

  updateRegistry(join.parent);
  updateRegistry(join.child);

  // Add the join to the joins array for this connection
  connections[connectionName].joins = connections[connectionName].joins.concat(join);

};


/**
 * Returns a new connection, if not yet registered, registers a new connection
 * into the registry.
 *
 * @param {String} connectionName
 * @return {Object}
 */

Connection.prototype.getConnection = function getConnection (connectionName) {

  // Default structure for connection objects
  var defaultConnection = {
    collections: [],
    children: [],
    joins: []
  };

  if(!this.registry[connectionName]) {
    this.registry[connectionName] = _.clone(defaultConnection);
  }

  return this.registry[connectionName];
};








Operations.prototype._getConnections = function _getConnections() {

  var self = this;
  var connections = {};

  // Default structure for connection objects
  var defaultConnection = {
    collections: [],
    children: [],
    joins: []
  };

  // For each join build a connection item to build up an entire collection/connection registry
  // for this query. Using this, queries should be able to be seperated into discrete queries
  // which can be run on connections in parallel.
  this.criteria.joins.forEach(function(join) {

    var connection;

    // Grab the parent collection
    var collection = self.context.waterline.collections[join.parent];

    // Find the connection object in the registry
    var connectionName = collection.adapterDictionary['find'];

    // If this join is a junctionTable, find the parent operation and add it to that connections
    // children instead of creating a new operation on another connection. This allows cross-connection
    // many-to-many joins to be used where the join relies on the results of the parent operation
    // being run first.

    if(join.junctionTable) {

      // Grab the parent collection
      collection = self.context.waterline.collections[join.parent];

      // Find the connection object in the registry
      connectionName = collection.adapterDictionary['find'];
      connections[connectionName] = connections[connectionName] || _.clone(defaultConnection);

      // Find the connection the child collection belongs to
      var childCollection = self.context.waterline.collections[join.child];
      var childConnectionName = childCollection.adapterDictionary['find'];

      // Add the child collection to it's connection object
      connections[childConnectionName] = connections[childConnectionName] || _.clone(defaultConnection);

      // Update the registry with the join values
      connections[childConnectionName].collections.push(join.child);
      connections[connectionName].children.push(join.parent);

      // Add the join to the joins array for this connection
      connections[connectionName].joins = connections[connectionName].joins.concat(join);

      return;
    }

    function updateRegistry(collName) {
      var collection = self.context.waterline.collections[collName];
      var connectionName = collection.adapterDictionary['find'];
      connections[connectionName] = connections[connectionName] || _.cloneDeep(defaultConnection);

      // Update the registry with the join values
      connections[connectionName].collections.push(collection.identity);
    }

    updateRegistry(join.parent);
    updateRegistry(join.child);

    // Add the join to the joins array for this connection
    connections[connectionName].joins = connections[connectionName].joins.concat(join);
  });

  console.log(require('util').inspect(connections, false, null));

  return connections;
};
